






#nuber of random samples 
N=5000
lambda=0.05

#sample size for 30,100
#size of random sample
n1=10

# need to do it for rate= 1, and 5

#going down row =random sample size, number of column=number of random samples
bootData<-replicate(n=15,expr=rexp(n1 ,rate=0.05))

lambdaHat=1/colMeans(bootData)

tInterval=replicate(200,0)
BootsCIs=array(dim=c(200,2))

XX=12

for (k in 1:15){
  
XX=lambdaHat[k]
###t interval for one random sample ; XX input is the estimated theta from original sample
# CreateCIsOfOneRandomSample <- function(XX) {
#   bootData2<-replicate(n=200,expr=rexp(n1 ,rate=0.05))#number of resample n=200
#   lambdaHat2=1/colMeans(bootData2)#the thetha j star
#   lambdaHat2SD=sd(lambdaHat2)#se of the thetha j star sample
#   
#   
#   for (i in 1:200){
#     
#     #produce t-interval
#     tInterval[i]=(lambdaHat2[i]-XX)/lambdaHat2SD
#   }
#   
#   boundaries=quantile(tInterval,c(0.05,0.95))
#   
#   BootsLower=XX-(boundaries[1]*lambdaHat2SD)
#   BootsUpper=XX-(boundaries[2]*lambdaHat2SD)
#   BootsCI=c(BootsLower,BootsUpper)
#   
#   return(BootsCI)
# }

BootsCIs[k,1:2]=CreateCIsOfOneRandomSample(XX)
}





#declare array
t_type_distribution.array <- array(0, dim=c(NumberOfResample*n1,n1*NumberOfResample))




for (j in 1:n1){
  
  for (i in 1:NumberOfResample){
    
    bootData2<-replicate(n=200,expr=rexp(n1 ,rate=0.05))
    lambdaHat2=1/colMeans(bootData2)
    lambdaHat2SD=sd(lambdaHat2)
    for (k in 1:200)
      
      t_type_distribution.array[i,j]=(lambdaHat2[i]-lambdaHat[j])/lambdaHat2SD
    
  }
}

quantile(t_type_distribution, c(.32, .57, .98)) 

#####To create 200 resample and find lambdaSD

bootData2<-replicate(n=200,expr=rexp(n1 ,rate=0.05))
lambdaHat2=1/colMeans(bootData2)#the thetha j star
lambdaHat2SD=sd(lambdaHat2)#se of the thetha j star sample
#use this to create confidence interval for one of the thetha original sample
















CreateCIsOfOneRandomSample <- function(XX) {
  bootData2<-replicate(n=200,expr=rexp(n1 ,rate=0.05))#number of resample n=200
  lambdaHat2=1/colMeans(bootData2)#the thetha j star
  lambdaHat2SD=sd(lambdaHat2)#se of the thetha j star sample
  
  
  for (i in 1:200){
    
    #produce t-interval
    tInterval[i]=(lambdaHat2[i]-XX)/lambdaHat2SD
  }
  
  boundaries=quantile(tInterval,c(0.05,0.95))
  
  BootsLower=XX-(boundaries[1]*lambdaHat2SD)
  BootsUpper=XX-(boundaries[2]*lambdaHat2SD)
  BootsCI=c(BootsLower,BootsUpper)
  
  return(BootsCI)
}

